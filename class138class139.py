# -*- coding: utf-8 -*-
"""class138class139.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s0HPnLWwNDlQh-nlnTSTfli7wQFslvX_
"""

!pip install Kaggle

from google.colab import files 
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d tmdb/tmdb-movie-metadata

!ls

!unzip tmdb-movie-metadata.zip

!ls

import pandas as pd
df1=pd.read_csv('tmdb_5000_credits.csv')
df2=pd.read_csv('tmdb_5000_movies.csv')
df1.head()
#df2.head()

df1.columns=['id','title','cast','crew']
df2=df2.merge(df1,on ='id')

df2.head()

"""Class139
Demographic Filtering

Weighted Rating=((v/(v+m))*R)+((m/(v+m))*C)




v - The number of votes for the movies (or number of ratings/reviews in case of an amazon product)
 ● m - The minimum votes required to be listed in the chart 
 ● R - Average rating of the movie ESR: Using Game States © 2020 - WhiteHat Education Technology Private Limited. Note: This document is the original copyright of WhiteHat Education Technology Private Limited. Please don't share, download or copy this file without permission. 5 
● C - Mean votes across the whole report
"""

C=df2['vote_average'].mean()
print(C)

m=df2['vote_count'].quantile(0.9)
print(m)

q_movies=df2.copy().loc[df2['vote_count']>=m]#to copy content of df2,loc-apply condition on copied data.
print(q_movies.shape)#no. of rows and column

def weightedRating(X,m=m,C=C):
  v=X['vote_count']
  R=X['vote_average']
  return(v/(v+m)*R)+(m/(v+m)*C)

q_movies['score']=q_movies.apply(weightedRating,axis=1)

#To sort the data in descending order
q_movies=q_movies.sort_values('score',ascending=False)
q_movies[['title_x','vote_count','vote_average','score']].head(10)

import plotly.express as px
fig=px.bar((q_movies.head(10).sort_values('score',ascending=True)),x='score',y='title_x',orientation='h')
fig.show()